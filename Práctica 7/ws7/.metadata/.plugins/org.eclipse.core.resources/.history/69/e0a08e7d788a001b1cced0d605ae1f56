package uo.mp.collections.impl;

import uo.mp.check.ArgumentChecks;
import uo.mp.collections.List;

public class LinkedList implements List {

	private Node head;
	private int numberOfElements;
	
	@Override
	public int size() {
		return numberOfElements;
	}

	@Override
	public boolean isEmpty() {
		return size()==0;
	}

	@Override
	public boolean contains(Object o) {
		return indexOf(o)!=-1;
	}

	@Override
	public void add(Object element) {
		ArgumentChecks.isTrue(element!=null);
		if (isEmpty()) {
			addFirst(element);
		} else {
			Node last = getNode(size()-1);
			last.next = new Node(element, null);
			numberOfElements++;
		}
	}
	
	public void addFirst(Object element) {
		head = new Node(element, head);
		numberOfElements++;
	}

	@Override
	public boolean remove(Object o) {
		if (isEmpty()) {
			return false;
		}
		int searched = indexOf(o);
		if (searched!=-1) {
			remove(searched);
			return true;
		}
		return false;
	}

	@Override
	public void clear() {
		Node aux = head;
		for (int i=0; i<size();i++) {
			remove(aux);
			aux = aux.next;
		}
		numberOfElements=0;
	}

	@Override
	public Object get(int index) {
		return getNode(index).value;
	}

	private Node getNode(int index) {
		int position = 0;
		Node node = head;
		while (position < index) {
			node = node.next;
			position++;
		}
		return node;
	}

	@Override
	public Object set(int index, Object value) {
		ArgumentChecks.bounds(index>0 && index<size());
		return getNode(index).value=value;
	}

	@Override
	public void add(int index, Object element) {
		ArgumentChecks.bounds(index>=0 && index<size());		
		ArgumentChecks.isTrue(element!=null);
		if (index==0) {
			addFirst(element);
		} else {
			Node previous = getNode(index-1);
			previous.next = new Node(element, previous.next);
			numberOfElements++;
		}
	}

	@Override
	public Object remove(int index) {
		if (isEmpty()) {
			return null;
		}
		Object value;
		if (index==0) {
			value = head.value;
			head = head.next;
		} else {
			Node previous = getNode(index-1);
			value = previous.next.value;
			previous.next = previous.next.next;
		}
		numberOfElements--;
		return value;
	}

	@Override
	public int indexOf(Object o) {
		Node aux = head;
		int i=0;
		while (aux!=null && !aux.value.equals(o)) {
			aux= aux.next;
			i++;
		}
		return aux==null?-1:i;
	}
}
